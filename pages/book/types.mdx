# Type system overview

import { Callout } from 'nextra/components'

Every variable, item, and value in Tact programs has a type. They can be:

* One of the [primitive types](#primitive-types)
* or [composite types](#composite-types)

Additionally, many of those types [can be made nullable](#optionals).

## Primitive types

Tact supports a number of primitive data types that are tailored for smart contract use:

* [`Int{:tact}`][ints] — all numbers in Tact are $257$-bit signed integers, but [smaller representations](/book/integers#serialization) can be used to reduce storage costs.
* [`Bool{:tact}`](#booleans) — classical boolean with `true{:tact}` and `false{:tact}` values.
* `Address{:tact}` — standard [smart contract address](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract) in TON Blockchain.
* `Slice{:tact}`, `Cell{:tact}`, `Builder{:tact}` — low-level primitives of TON VM.
* `String{:tact}` — represents text strings in TON VM.
* `StringBuilder{:tact}` — helper type that allows you to concatenate strings in a gas-efficient way.

[ints]: /book/integers

### Booleans [#booleans]

The primitive type `Bool{:tact}` is the classical boolean type, which can hold only the two values: `true{:tact}` and `false{:tact}`. It's convenient for boolean and logical operations, as well as for storing flags.

There are no implicit type conversions in Tact, so addition (`+{:tact}`) of two boolean values isn't possible. Hovewer, many comparison [operators](/book/statements#operators) are available, such as:

* `&&{:tact}` for [logical AND](/book/operators#binary-logical-and),
* `||{:tact}` for [logical OR](/book/operators#binary-logical-or),
* `!{:tact}` for [logical inversion](/book/operators#unary-inverse),
* `=={:tact}` for checking [equality](/book/operators#binary-equal),
* `!={:tact}` for checking [inequality](/book/operators#binary-not-equal),
* and `!!{:tact}` for [non-null assertion](/book/optionals).

Persisting bools to state is very space-efficient, as they only take 1-bit. Storing 1000 bools in state [costs](https://ton.org/docs/develop/smart-contracts/fees#how-to-calculate-fees) about $0.00072$ TON per year.

## Composite types

Using individual means of storage often becomes cumbersome, so there are ways to combine multiple [primitive types](#primitive-types) together to create composite types:

* [Maps](#maps) — associations of keys with values.
* [Structs and Messages](#structs-and-messages) — data structures with typed fields.
* [Optionals](#optionals) — `null{:tact}` values for variables or fields of [Structs and Messages](#structs-and-messages).

Note, while [contracts](#contracts) and [traits](#traits) are also considered a part of the Tacts type system, one can't pass them around like [Structs and Messages](#structs-and-messages). Instead, it's possible to obtain the initial state of the given contract by using the [`initOf{:tact}`](/book/expressions#initof) expression.

### Maps

The type [`map<k, v>{:tact}`][maps] is used as a way to associate keys of type `k` with corresponding values of type `v`.

Example of a [`map<k, v>{:tact}`][maps]:

```tact
let mapExample: map<Int, Int> = emptyMap(); // empty map with Int keys and values
```

Learn more about them on a dedicated page: [Maps][maps].

[maps]: /book/maps

### Structs and Messages

[Structs][structs] and [Messages][messages] are two main ways of combining multiple [primitive types](#primitive-types) into a composite one.

Example of a [Struct][structs]:

```tact
struct Point {
    x: Int;
    y: Int;
}
```

Example of a [Message][messages]:

```tact
// Custom numeric id of the Message
message(0x11111111) SetValue {
    key: Int;
    value: Int?; // Optional, Int or null
    coins: Int as coins; // Serialization into TL-B types
}
```

Learn more about them on a dedicated page: [Structs and Messages][s-n-m].

[s-n-m]: /book/structs-and-messages
[structs]: /book/structs-and-messages#structs
[messages]: /book/structs-and-messages#messages

### Optionals

All [primitive types](#primitive-types), as well as [Structs and Messages](#structs-and-messages) could be nullable and hold a special `null{:tact}` value.

Example of an [optional][optionals]:

```tact
let opt: Int? = null; // Int or null, with explicitly assigned null
```

Learn more about them on a dedicated page: [Optionals][optionals].

[optionals]: /book/optionals

### Contracts

Contracts are the main entry of a smart contract on the TON blockchain. It holds all [functions](/book/functions), [getters](/book/functions#getter-functions), and [receivers](/book/functions#receiver-functions) of a TON contract.

Contracts and [traits](#traits) have a built-in [identifier](/book/expressions#identifiers) `self{:tact}`, which is used for referring to their fields (persistent state variables) and methods (internal functions).

```tact
// Basic example of a counter contract:
contract HelloWorld {
    counter: Int;

    init() {
        self.counter = 0;
    }

    receive("increment") {
        self.counter += 1;
    }

    get fun counter(): Int {
        return self.counter;
    }
}
```

### Traits

Tact doesn't support classical class inheritance, but instead introduces the concept of **traits**. Trait defines functions, receivers, and required fields. The trait is like abstract classes, but it does not define how and where fields must be stored. **All** fields from all traits must be explicitly declared in the contract itself. Traits themselves don't have `init(){:tact}` constructors, so all initial field initialization also must be done in the main contract.

```tact
trait Ownable {
    owner: Address;

    fun requireOwner() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    get fun owner(): Address {
        return self.owner;
    }
}
```

And the contract that uses trait:

```tact
contract Treasure with Ownable {
    owner: Address; // Field from trait MUST be defined in contract itself

    // Here we init the way we need, trait can't specify how you must init owner field
    init(owner: Address) {
        self.owner = owner;
    }
}
```