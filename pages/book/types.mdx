# Type system overview

import { Callout } from 'nextra/components'

Every variable, item, and value in Tact programs has a type. They can be:

* One of the [primitive types](#primitive-types)
* [Maps](#maps)
* Composite types, such as [Structs and Messages](#structs-and-messages)
* or [Contracts](#contracts) and [Traits](#traits)

Also, many of those types [can be made nullable](/book/composite-types#optionals).

## Primitive types

* [`Int{:tact}`][int] — all numbers in Tact are $257$-bit signed integers, but [smaller representations](/book/integers#serialization) can be used to reduce storage costs.
* [`Bool{:tact}`](#booleans) — classical boolean with `true{:tact}` and `false{:tact}` values.
* `Address{:tact}` — standard [smart contract address](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract) in TON Blockchain.
* `Slice{:tact}`, `Cell{:tact}`, `Builder{:tact}` — low-level primitives of TON VM.
* `String{:tact}` — represents text strings in TON VM.
* `StringBuilder{:tact}` — helper type that allows you to concatenate strings in a gas-efficient way.

## Booleans

The primitive type `Bool{:tact}` can hold only the two values: `true{:tact}` and `false{:tact}`. It's convenient for boolean and logical operations, as well as for storing flags.

There are no implicit type conversions in Tact, so addition (`+{:tact}`) of two boolean values isn't possible. Hovewer, many comparison [operators](/book/statements#operators) are available, such as:

* `&&{:tact}` for [logical AND](/book/operators#binary-logical-and),
* `||{:tact}` for [logical OR](/book/operators#binary-logical-or),
* `!{:tact}` for [logical inversion](/book/operators#unary-inverse),
* `=={:tact}` for checking [equality](/book/operators#binary-equal),
* `!={:tact}` for checking [inequality](/book/operators#binary-not-equal),
* and `!!{:tact}` for [non-null assertion](/book/composite-types#optionals).

Persisting bools to state is very space-efficient, as they only take 1-bit. Storing 1000 bools in state [costs](https://ton.org/docs/develop/smart-contracts/fees#how-to-calculate-fees) about $0.00072$ TON per year.

## Maps

The type `map<k, v>{:tact}` is used as a way to associate values of type `v` with corresponding keys of type `k`.

Possible key types:

* [`Int{:tact}`][int]
* `Address{:tact}`

Possible value types:

* [`Int{:tact}`][int]
* [`Bool{:tact}`](#booleans)
* `Cell{:tact}`
* `Address{:tact}`
* [Struct](#structs-and-messages)
* [Message](#structs-and-messages)

For example, `map<Int, Int>{:tact}` uses [`Int{:tact}`][int] type for its keys and values:

```tact
struct IntToInt {
    counters: map<Int, Int>;
}
```

Additionally, maps allow [integer serialization](/book/integers#serialization-types) of its keys, values or both to [preserve space and reduce storage costs](/book/integers#serialization):

```tact
struct SerializedMapInside {
    countersButCompact: map<Int as uint8, Int as uint8>;
}
```

<Callout>

  Other serialization options are available too: [Compatibility with FunC](/book/func#convert-serialization)

</Callout>

[int]: /book/integers

## Structs and Messages

[Structs][structs] and [Messages][messages] are two main ways of combining multiple [primitive types](#primitive-types) into a composite one.

Example of a [Struct][structs]:

```tact
struct Point {
    x: Int;
    y: Int;
}
```

Example of a [Message][messages]:

```tact
// Custom numeric id of the Message
message(0x11111111) SetValue {
    key: Int;
    value: Int?; // Optional, Int or null
    coins: Int as coins; // Serialization into TL-B types
}
```

Learn more about them on a dedicated page about [composite types](/book/composite-types).

[structs]: /book/composite-types#structs
[messages]: /book/composite-types#messages

## Contracts

Contracts are the main entry of a smart contract on the TON blockchain. It holds all [functions](/book/functions), [getters](/book/functions#getter-functions), and [receivers](/book/functions#receiver-functions) of a TON contract.

```tact
// Basic example of a counter contract:
contract HelloWorld {
    counter: Int;

    init() {
        self.counter = 0;
    }

    receive("increment") {
        self.counter = self.counter + 1;
    }

    get fun counter(): Int {
        return self.counter;
    }
}
```

## Traits

Tact doesn't support classical class inheritance, but instead introduces the concept of **traits**. Trait defines functions, receivers, and required fields. The trait is like abstract classes, but it does not define how and where fields must be stored. **All** fields from all traits must be explicitly declared in the contract itself. Traits themselves don't have `init(){:tact}` constructors, so all initial field initialization also must be done in the main contract.

```tact
trait Ownable {
    owner: Address;

    fun requireOwner() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    get fun owner(): Address {
        return self.owner;
    }
}
```

And the contract that uses trait:

```tact
contract Treasure with Ownable {
  owner: Address; // Field from trait MUST be defined in contract itself

  // Here we init the way we need, trait can't specify how you must init owner field
  init(owner: Address) {
    self.owner = owner;
  }
}
```