# Debug

import { Callout } from 'nextra-theme-docs'

## require

```tact
fun require(condition: Bool, error: String);
```

Checks the `condition` and throws an exception with `error` message if the `condition` is `false{:tact}`. Does nothing otherwise.

Usage example:

```tact
// now() has to return a value greater than 1000, otherwise an error message will be thrown
require(now() > 1000, "We're in the first 1000 seconds of 1 January 1970!");
```

## dump

```tact
fun dump(arg);
```

Prints the argument `arg` to the contract's debug console. Evaluated only if `debug` option is set in the [configuration file](/book/config), otherwise does nothing.

Can be applied to the following list of types and values:

* [`Int{:tact}`][int]
* [`Bool{:tact}`][bool]
* [`Address{:tact}`][p]
* [`Builder{:tact}`][p], [`Cell{:tact}`][p] or [`Slice{:tact}`][p]
* [`String{:tact}`][p] or [`StringBuilder{:tact}`][p]
* [`map<K, V>{:tact}`](/book/maps)
* [Optionals and `null{:tact}` value](/book/optionals)
* `void`, which is implicitly returned when a function doesn't have return value defined

Usage examples:

```tact
// Int
dump(42);

// Bool
dump(true);
dump(false);

// Address
dump(myAddress());

// Builder, Cell or Slice
dump(beginCell());           // Builder
dump(emptyCell());           // Cell
dump(emptyCell().asSlice()); // Slice

// String or StringBuilder
dump("Hello, my name is..."); // String
dump(beginTailString());      // StringBuilder

// Maps
let m: map<Int, Int> = emptyMap();
m.set(2 + 2, 4);
dump(m);

// Special values
dump(null);
dump(emit("msg".asComment())); // As emit() function doesn't return a value, dump() would print #DEBUG#: void.
```

## dumpStack

```tact
fun dumpStack();
```

Prints all the values of [persistent state variables](/book/contracts#variables) to the contract's debug console. Evaluated only if `debug` option is set in the [configuration file](/book/config), otherwise does nothing.

Usage example:

```tact
contract DumpsterFire {
    var1: Int = 0;
    var2: Int = 5;

    receive() {
        dumpStack(); // would print 0 5
    }
}
```

## throw

```tact
fun throw(code: Int);
```

An alias to [`nativeThrow(){:tact}`](#nativethrow).

## nativeThrow

```tact
fun nativeThrow(code: Int);
````

Throws an exception with an error code equal to `code`. Execution of the current context stops (the statements after `nativeThrow` won't be executed) and control will be passed to the first [`try...catch{:tact}` block](/book/statements#try-catch) in the call stack. If no `try{:tact}` or `try...catch{:tact}` block exists among caller functions, [TVM](https://docs.ton.org/learn/tvm-instructions/tvm-overview) will terminate the transaction.

Usage examples:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrow(42); // throwing with exit code 42
}

fun butThisDoesnt() {
    try {
        nativeThrow(42); // throwing with exit code 42
    }

    // ... follow-up logic ...
}
```

<Callout>

  Prefer to use `require(){:tact}` over this function as the former comes with more [compile-time](/ref/api-comptime) optimizations and is generally more user-friendly.

</Callout>

## nativeThrowWhen

```tact
fun nativeThrowWhen(code: Int, condition: Bool);
```

Similar to [`nativeThrow(){:tact}`](#nativethrow), but with throw an exception conditionally, when `condition` is equal to `true{:tact}`. Won't throw otherwise.

Usage examples:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowWhen(42, true); // throwing with exit code 42
}

fun butThisDoesnt() {
    try {
        nativeThrow(42, true); // throwing with exit code 42
    }
    // ... follow-up logic ...
}
```

<Callout>

  Prefer to use `require(){:tact}` over this function as the former comes with more [compile-time](/ref/api-comptime) optimizations and is generally more user-friendly.

</Callout>

## nativeThrowUnless

```tact
fun nativeThrowUnless(code: Int, condition: Bool);
```

Similar to [`nativeThrow(){:tact}`](#nativethrow), but with throw an exception conditionally, when `condition` is equal to `false{:tact}`. Won't throw otherwise.

Usage examples:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowUnless(42, false); // throwing with exit code 42
}

fun butThisDoesnt() {
    try {
        nativeThrowUnless(42, false); // throwing with exit code 42
    }
    // ... follow-up logic ...
}
```

<Callout>

  Prefer to use `require(){:tact}` over this function as the former comes with more [compile-time](/ref/api-comptime) optimizations and is generally more user-friendly.

</Callout>

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
