# Strings and StringBuilders

import { Callout } from 'nextra-theme-docs'

Strings are immutable sequences of characters, which means that once a [`String{:tact}`][p] is created, it cannot be changed. Strings are useful to store text, and so they can be converted to [`Cell{:tact}`][p] type to be used as message bodies.

To be able to concatenate strings in a gas-efficient way, use a [`StringBuilder{:tact}`][p].

To use [`String{:tact}`][p] literals directly, see: [String literals](/book/expressions#string-literals).

## beginString

```tact
fun beginString(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
```

## beginComment

```tact
fun beginComment(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p] for building a comment string, which prefixes the resulting [`String{:tact}`][p] with four null bytes. This format is used for passing text comments for message bodies.

Usage example:

```tact
let fizz: StringBuilder = beginComment();
```

## beginTailString

```tact
fun beginTailString(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p] for building a tail string, which prefixes the resulting [`String{:tact}`][p] with a single null byte. This format is used in various standards like NFT or Jetton.

Usage example:

```tact
let fizz: StringBuilder = beginTailString();
```

## beginStringFromBuilder

```tact
fun beginStringFromBuilder(b: StringBuilder): StringBuilder;
```

Creates and returns a new [`StringBuilder{:tact}`][p] from existing [`StringBuilder{:tact}`][p] `b`. Useful when you need to serialize an existing [`String{:tact}`][p] to a [`Cell{:tact}`][p] with some other data.

Usage example:

```tact
let fizz: StringBuilder = beginStringFromBuilder(beginString());
```

## StringBuilder.append

```tact
extends mutates fun append(self: StringBuilder, s: String);
```

Extension mutation function for the [`StringBuilder{:tact}`][p].

Appends a [`String{:tact}`][p] `s` to the [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
fizz.append("oh");
fizz.append("my");
fizz.append("Tact!");
```

## StringBuilder.concat

```tact
extends fun concat(self: StringBuilder, s: String): StringBuilder;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns a new [`StringBuilder{:tact}`][p] after concatinating it with a [`String{:tact}`][p] `s`. Can be chained, unlike [`StringBuilder.append(){:tact}`](#stringbuilderappend).

Usage example:

```tact
let fizz: StringBuilder = beginString()
    .concat("oh")
    .concat("my")
    .concat("Tact!");
```

## StringBuilder.toString

```tact
extends fun toString(self: StringBuilder): String;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns a built [`String{:tact}`][p] from a [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
let buzz: String = fizz.toString();
```

## StringBuilder.toCell

```tact
extends fun toCell(self: StringBuilder): Cell;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns an assembled [`Cell{:tact}`][p] from a [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
let buzz: Cell = fizz.toCell();
```

## StringBuilder.toSlice

```tact
extends fun toSlice(self: StringBuilder): Slice;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns an assembled [`Cell{:tact}`][p] as a [`Slice{:tact}`][p] from a [`StringBuilder{:tact}`][p]. Alias to [`self.toCell().asSlice(){:tact}`](/ref/api-cells#cellasslice).

Usage example:

```tact
let s: StringBuilder = beginString();
let fizz: Slice = s.toSlice();
let buzz: Slice = s.toCell().asSlice();

fizz == buzz; // true
```

## String.asSlice

```tact
extends fun asSlice(self: String): Slice;
```

Extension function for the [`String{:tact}`][p].

Returns a [`Slice{:tact}`][p] from a [`String{:tact}`][p] by trying to pack all of its bytes into a continuous list of [Cells][p], each referencing the next one and opening them all for future parsing.

Note, that there's no indication of how many bytes a particular character could take in the [`Slice{:tact}`][p] or how deep the list of references is going to be, so use this function only if you know what you're doing.

Usage example:

```tact
let s: String = "123";
let fizz: Slice = s.toSlice();
let buzz: Slice = s.toCell().asSlice();

fizz == buzz; // true
```

<Callout>

  See the enhanced version of this example in the Cookbook: [How to convert a `String` to an `Int`](/cookbook/type-conversion#how-to-convert-a-string-to-an-int).

</Callout>

## String.asComment

```tact
extends fun asComment(self: String): Cell
```

Converts String `self` to comment message body Cell.

{/* TODO: is it? Alias to beginComment().concat(self).toCell(); */}

## String.fromBase64

```tact
extends fun fromBase64(self: String): Slice;
```

Decodes base64 string to a slice. NOTE: This method is very limited and can be used only for small strings that fit in a single cell.

{/* TODO: Alias for asSlice.fromBase64 */}

## Slice.asString

```tact
extends fun asString(self: Slice): String;
```

**Dangerously** casts slice as string. Use it only if you know what you are doing.

{/* TODO: describe what's actually going on using the Cookbook example (type conversions page). */}

## Slice.fromBase64

```tact
extends fun fromBase64(self: Slice): Slice;
```

Decodes base64 slice to a slice.

## Int.toString

```tact
extends fun toString(self: Int): String;
```

Converts Int value to String

## Int.toFloatString

```tact
extends fun toFloatString(self: Int, digits: Int): String
```

Converts Fixed Float value that represented as Int to String

Where,
* `self` significant part of float number as Int number;
* `digits` is a exponentiation parameter of expression `10^(-digits)` that will be used for computing float number. `digits` required to be `0 <= digits < 77`.

## Int.toCoinsString

```tact
extends fun toCoinsString(self: Int): String
```

Converts nanoToncoin Int value `self` to String float number of Toncoins and returns it as a result.

{/* TODO: What does it mean??? Make note that it uses toFloatString(9) */}

## Address.toString

```tact
extends fun toString(self: Address): String;
```

Extension function for the [`Address{:tact}`][p].

Converts an [`Address{:tact}`][p] to a String.

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
