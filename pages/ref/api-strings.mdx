# Strings and StringBuilders

import { Callout } from 'nextra-theme-docs'

Strings are immutable sequences of characters, which means that once a [`String{:tact}`][p] is created, it cannot be changed. Strings are useful to store text, and so they can be converted to [`Cell{:tact}`][p] type to be used as message bodies.

To be able to concatenate strings in a gas-efficient way, use a [`StringBuilder{:tact}`][p].

To use [`String{:tact}`][p] literals directly, see: [String literals](/book/expressions#string-literals).

## beginString

```tact
fun beginString(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
```

## beginComment

```tact
fun beginComment(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p] for building a comment string, which prefixes the resulting [`String{:tact}`][p] with four null bytes. This format is used for passing text comments as message bodies.

Usage example:

```tact
let fizz: StringBuilder = beginComment();
```

## beginTailString

```tact
fun beginTailString(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p] for building a tail string, which prefixes the resulting [`String{:tact}`][p] with a single null byte. This format is used in various standards like NFT or Jetton.

Usage example:

```tact
let fizz: StringBuilder = beginTailString();
```

## beginStringFromBuilder

```tact
fun beginStringFromBuilder(b: StringBuilder): StringBuilder;
```

Creates and returns a new [`StringBuilder{:tact}`][p] from existing [`StringBuilder{:tact}`][p] `b`. Useful when you need to serialize an existing [`String{:tact}`][p] to a [`Cell{:tact}`][p] with some other data.

Usage example:

```tact
let fizz: StringBuilder = beginStringFromBuilder(beginString());
```

## StringBuilder.append

```tact
extends mutates fun append(self: StringBuilder, s: String);
```

Extension mutation function for the [`StringBuilder{:tact}`][p].

Appends a [`String{:tact}`][p] `s` to the [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
fizz.append("oh");
fizz.append("my");
fizz.append("Tact!");
```

## StringBuilder.concat

```tact
extends fun concat(self: StringBuilder, s: String): StringBuilder;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns a new [`StringBuilder{:tact}`][p] after concatinating it with a [`String{:tact}`][p] `s`. Can be chained, unlike [`StringBuilder.append(){:tact}`](#stringbuilderappend).

Usage example:

```tact
let fizz: StringBuilder = beginString()
    .concat("oh")
    .concat("my")
    .concat("Tact!");
```

## StringBuilder.toString

```tact
extends fun toString(self: StringBuilder): String;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns a built [`String{:tact}`][p] from a [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
let buzz: String = fizz.toString();
```

## StringBuilder.toCell

```tact
extends fun toCell(self: StringBuilder): Cell;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns an assembled [`Cell{:tact}`][p] from a [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
let buzz: Cell = fizz.toCell();
```

## StringBuilder.toSlice

```tact
extends fun toSlice(self: StringBuilder): Slice;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns an assembled [`Cell{:tact}`][p] as a [`Slice{:tact}`][p] from a [`StringBuilder{:tact}`][p]. Alias to [`self.toCell().asSlice(){:tact}`](/ref/api-cells#cellasslice).

Usage example:

```tact
let s: StringBuilder = beginString();
let fizz: Slice = s.toSlice();
let buzz: Slice = s.toCell().asSlice();

fizz == buzz; // true
```

## String.asSlice

```tact
extends fun asSlice(self: String): Slice;
```

Extension function for the [`String{:tact}`][p].

Returns a [`Slice{:tact}`][p] from a [`String{:tact}`][p] by trying to pack all of its bits into a continuous list of [Cells][p], each referencing the next one and opening them all for future parsing.

Note, that there's no indication of how many bytes a particular character could take in the [`Slice{:tact}`][p] or how deep the list of references is going to be, so use this function only if you know what you're doing.

Usage example:

```tact
let s: String = "It's alive! It's alive!!!";
let fizz: Slice = s.asSlice();
let buzz: Slice = s.asSlice().asString().asSlice();

fizz == buzz; // true, but be careful as it's not always the case
```

<Callout>

  See how `String.asSlice{:tact}` function can be used in practice: [How to convert a `String` to an `Int`](/cookbook/type-conversion#how-to-convert-a-string-to-an-int).

</Callout>

## String.asComment

```tact
extends fun asComment(self: String): Cell;
```

Extension function for the [`String{:tact}`][p].

Returns a [`Cell{:tact}`][p] from a [`String{:tact}`][p] by prefixing the latter with four null bytes. This format is used for passing text comments as message bodies.

Usage example:

```tact
let s: String = "When life gives you lemons, call them 'yellow oranges' and sell them for double the price.";
let fizz: Cell = s.asComment();

let b: StringBuilder = beginComment();
b.append(s);
let buzz: Cell = b.toCell();

fizz == buzz; // true
```

## String.fromBase64

```tact
extends fun fromBase64(self: String): Slice;
```

Extension function for the [`String{:tact}`][p].

Returns a [`Slice{:tact}`][p] out of the decoded [Base64](https://en.wikipedia.org/wiki/Base64) [`String{:tact}`][p]. Alias to `self.asSlice().fromBase64(){:tact}`.

Note, that this function is very limited and can be used only for small strings that fit in a single [`Cell{:tact}`][p] (i.e., strings that contain no more than 1023 bits of data).

Usage example:

```tact
let s: String = "SGVyZSdzIEpvaG5ueSE=";
let fizz: Slice = s.fromBase64();
let buzz: Slice = s.asSlice().fromBase64();

fizz == buzz; // true
```

## Slice.asString

```tact
extends fun asString(self: Slice): String;
```

Extension function for the [`Slice{:tact}`][p].

Returns a [`String{:tact}`][p] from a [`Slice{:tact}`][p] by trying to load all of its bits without looking for its references, if any.

Note, that this function doesn't look at the references at all and is truncates its output to 1023 bits, so use it only if you know what you're doing.

Usage example:

```tact
let s: String = "Keep your Slices close, but your Strings closer.";
let fizz: String = s;
let buzz: String = s.asSlice().asString();

fizz == buzz; // true, but be careful as it's not always the case
```

## Slice.fromBase64

```tact
extends fun fromBase64(self: Slice): Slice;
```

Extension function for the [`Slice{:tact}`][p].

Returns a [`Slice{:tact}`][p] out of the decoded [Base64](https://en.wikipedia.org/wiki/Base64) [`Slice{:tact}`][p].

Note, that this function doesn't load [`Cell{:tact}`][p] references, which makes it limited to only 1023 bits of data.

Usage example:

```tact
let s: Slice = "SSBhbSBHcm9vdC4=".asSlice();
let fizz: Slice = s.fromBase64();
```

## Int.toString

```tact
extends fun toString(self: Int): String;
```

Extension function for the [`Int{:tact}`][int].

Returns a [`String{:tact}`][p] from an [`Int{:tact}`][int] value.

Usage example:

```tact
let fizz: String = (84 - 42).toString();
```

## Int.toFloatString

```tact
extends fun toFloatString(self: Int, digits: Int): String;
```

Extension function for the [`Int{:tact}`][int].

Returns a [`String{:tact}`][p] from an [`Int{:tact}`][int] value using a [fixed-point representation](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) of a fractional number, where `self` is a significant part of the number and `digits` is a number of digits in the fractional part.

More precisely, `digits` is an exponentiation parameter of $10^{-\mathrm{digits}}$ expression, which constitutes the represented number. Parameter `digits` is required to be in the range $0 <=$ `digits` $< 77$.

Usage example:

```tact
let fizz: String = (42).toFloatString(9); // "0.000000042"
```

## Int.toCoinsString

```tact
extends fun toCoinsString(self: Int): String;
```

Extension function for the [`Int{:tact}`][int].

Returns a [`String{:tact}`][p] from an [`Int{:tact}`][int] value using a [fixed-point representation](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) of a fractional number. Alias to `self.toFloatString(9){:tact}`.

This is used to represent nanoToncoin (nano-ton) [`Int{:tact}`][int] values using strings.

Usage example:

```tact
let nanotons: Int = 42;
let fizz: String = nanotons.toCoinsString();
let buzz: String = nanotons.toFloatString(9);

fizz == buzz; // true, both store "0.000000042"
```

## Address.toString

```tact
extends fun toString(self: Address): String;
```

Extension function for the [`Address{:tact}`][p].

Returns a [`String{:tact}`] from an [`Address{:tact}`][p].

Usage example:

```tact
let community: Address = address("UQDpXLZKrkHsOuE_C1aS69C697wE568vTnqSeRfBXZfvmVOo");
let fizz: String = community.toString();
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
