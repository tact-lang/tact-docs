import { Callout } from 'nextra/components'

# Cookbook Overview

The core reason for creating the Tact Cookbook is to collect all the experience from Tact developers in one place so that future developers will use it. Compared to the rest of the documentation, this section is more focused on everyday tasks every Tact developer resolves during the development of smart contracts.

## Basics

### How to write a Hello World smart contract

```tact
contract HelloWorld {
    // Note, that an empty init function won't be needed starting with Tact 1.3.0,
    // see: https://github.com/tact-lang/tact/pull/167
    init() {}
    get fun greeting(): String {
        return "Hello, World!";
    }
}
```

### How to write an `if` statement in Tact

Tact supports `if...else{:tact}` statements in a similar syntax to most programming languages. The condition of the statement can be any boolean expression.

```tact
let value: Int = 9001;

if (value > 10) {
    // do something
}

if (value > 100) {
    // do something
} else {
    // do something else
}

if (value > 9000) {
    // do something
} else if (value > 500) {
    // do another thing
} else {
    // do something else
}
```

## Loops

### How to write a `repeat` loop

Please make sure the input number for the [`repeat{:tact}`](/book/statements#repeat-loop) loop statement is within the range of an $32$-bit [`Int{:tact}`](/book/integers) data type, as an exception will be thrown otherwise.

```tact
let sum: Int = 0;
let i: Int = 0;

repeat (10) {               // repeat exactly 10 times
    i += 1;
    sum += i;
}

```
<Callout>

  **Useful links:**\
  [`repeat{:tact}` loop in the Book](/book/statements#repeat-loop)\
  [Loops in Tact-By-Example](https://tact-by-example.org/04-loops)

</Callout>

### How to write a `while` loop

```tact
let i: Int = 0;

while (i < 10) {
    i += 1;
}
```

<Callout>

  **Useful links:**\
  [`while{:tact}` loop in the Book](/book/statements#while-loop)\
  [Loops in Tact-By-Example](https://tact-by-example.org/04-loops)

</Callout>


### How to write a `do...until` loop [#how-to-write-a-do-until-loop]

When we need the cycle to run at least once, we use the [`do...until{:tact}`](/book/statements#do-until-loop) loop.

```tact
let num: Int;               // A variable to store the random number

// A do until loop that repeats until num is equal to 5
do {
    num = random(0, 9);     // get a random number between 0 and 9
} until (num == 5);         // stop loop if num is equal to 5

dump("The loop is over!");
```

<Callout>

  **Useful links:**\
  [`do...until{:tact}` loop in the Book](/book/statements#do-until-loop)\
  [`random()` in Language→Reference](/language/ref/random#random)\
  [Loops in Tact-By-Example](https://tact-by-example.org/04-loops)

</Callout>

## Map

For description and basic usage see [`map<k, v>{:tact}` type in the Book](/book/maps).

### How to iterate over map entries

```tact
import "@stdlib/deploy"; // for Deployable trait

contract Iteration with Deployable {
    // Persistent state variables
    counter: Int as uint32;    // counter of map entries, serialized as a 32-bit unsigned
    record: map<Int, Address>; // Int to Address map

    // Constructor (initialization) function of the contract
    init() {
        self.counter = 0; // Setting the self.counter to 0
    }

    // Internal message receiver, which responds to a String message "Add"
    receive("Add") {
        // Get the Context Struct
        let ctx: Context = context();
        // Set the entry: counter Int as a key, ctx.sender Address as a value
        self.record.set(self.counter, ctx.sender);
        // Increase the counter
        self.counter += 1;
    }

    // Internal message receiver, which responds to a String message "Send"
    receive("Send") {
        // Loop until the value of self.counter (over all the self.record entries)
        let i: Int = 0; // declare usual i for loop iterations
        while (i < self.counter) {
           send(SendParameters{
                bounce: false,              // do not bounce back this message
                to: self.record.get(i)!!,   // set the sender address, knowing that key i exists in the map
                value: ton("0.0000001"),    // 100 nanoToncoins (nano-tons)
                mode: SendIgnoreErrors,     // send ignoring errors in transaction, if any
                body: "SENDING".asComment() // String "SENDING" converted to a Cell as a message body
            });
            i += 1; // don't forget to increase the i
        }
    }

    // Getter function for obtaining the value of self.record
    get fun map(): map<Int, Address> {
        return self.record;
    }

    // Getter function for obtaining the value of self.counter
    get fun counter(): Int {
        return self.counter;
    }
}
```

<Callout>

  This example is adapted from [howardpen9/while-example-tact](https://github.com/howardpen9/while-example-tact/blob/de5807fcd20dba5f6a3748d112511477fb22bfcc/contracts/awesome.tact#L19C10-L19C10).

</Callout>

### How to make a cyclic array with a map

```tact
import "@stdlib/deploy"; // for Deployable trait

// This contract records the last 5 timestamps of when "timer" message was received
contract Arrays with Deployable {
    // Declare a compile-time constant upper bound for our map representing a buffer
    const MaxBufferSize: Int = 42;

    // Persistent state variables
    buffer: map<Int, Int>; // this is our buffer implemented with a map
    bufferLength: Int as uint8 = 0;
    bufferStart: Int as uint8 = 0; // current index into the buffer

    // Constructor (initialization) function of the contract
    init() {}

    // Internal function for adding a new item into the buffer
    fun bufferPush(item: Int) {
        if (self.arrLength < self.MaxSize) {
            self.arr.set(self.arrLength, item);
            self.arrLength = self.arrLength + 1;
        } else {
            self.arr.set(self.arrStart, item);
            self.arrStart = (self.arrStart + 1) % self.MaxSize;
        }
    }

    // Iterate over all items in the array and dump them
    fun arrPrint() {
        let i: Int = self.arrStart;
        repeat (self.arrLength) {
            dump(self.arr.get(i)!!); // !! tells the compiler this can't be null
            i = (i + 1) % self.MaxSize;
        }
    }

    // Internal message receiver, which responds to a String message "timer"
    // and records the timestamp when it receives such message
    receive("timer") {
        let timestamp: Int = now();
        self.arrPush(timestamp);
    }

    receive("dump") {
        self.arrPrint();
    }

    get fun length(): Int {
        return self.arrLength;
    }

    get fun map(): map<Int, Int> {
        return self.arr;
    }
}
```

<Callout>

  This example is adapted from [Arrays page in Tact-By-Example](https://tact-by-example.org/04-arrays).

</Callout>

## `Slice`

### How to determine if a `Slice` is empty

A [`Slice{:tact}`](/book/types#primitive-types) is considered _empty_ if it has no stored `data` **and** no stored `references`.

Use `empty(){:tact}` method to check if a [`Slice{:tact}`](/book/types#primitive-types) is empty.

```tact
// Create an empty Slice with no data and no refs
let empty_slice: Slice = emptyCell().asSlice();
// Returns `true`, because `empty_slice` doesn't have any data or refs
empty_slice.empty();

// Create a slice with some data
let slice_with_data: Slice = beginCell().
    storeUint(42, 8).
    asSlice();
// Returns `false`, because the slice has some data
slice_with_data.empty();

// Create a slice with a reference to an empty cell
let slice_with_refs: Slice  = beginCell().
    storeRef(emptyCell()).
    asSlice();
// Returns `false`, because the slice has a reference
slice_with_refs.empty();

// Create a slice with data and a reference
let slice_with_data_and_refs: Slice  = beginCell().
    storeUint(42, 8).
    storeRef(emptyCell()).
    asSlice();
// Returns `false`, because the slice has both data and reference
slice_with_data_and_refs.empty();
```

### How to determine if a `Slice` has no refs (but may have bits)

```tact
let slice_with_data: Slice = beginCell().
    storeUint(0, 1).
    asSlice(); // create a slice with data but without refs
let refsCount: Int = slice_with_data.refs(); // 0
let hasNoRefs: Bool = slice_with_data.refsEmpty(); // true
```

### How to determine if a `Slice` has no data (no bits, but may have refs)

```tact
let slice_with_data: Slice = beginCell().
    storeRef(emptyCell()).
    asSlice(); // create a slice with ref but without data
let bitsCount: Int = slice_with_data.bits(); // 0
let hasNoData: Bool = slice_with_data.dataEmpty(); // true
```

### How to determine if two Slices are equal

Direct comparison:

```tact
let firstSlice: Slice = "A".asSlice();
let secondSlice: Slice = "A".asSlice();

let areEqual: Bool = firstSlice == secondSlice;
let areNotEqual: Bool = firstSlice != secondSlice;

dump(areEqual) // true;
dump(areNotEqual) // false;
```

Note, that direct comparison via `=={:tact}` or `!={:tact}` operators implicitly uses hashes under the hood.

Explicit comparisons using `.hash(){:tact}` are also available:

```tact
fun areSlicesEqual(a: Slice, b: Slice): Bool {
    return a.hash() == b.hash();
}

let firstSlice: Slice = "A".asSlice();
let secondSlice: Slice = "A".asSlice();

let result: Bool = areSlicesEqual(firstSlice, secondSlice);
dump(result) // true;
```

<Callout>

  **Useful links:**\
  [`String.asSlice(){:tact}` in Language→Reference](/language/ref/strings#stringasslice)

</Callout>

## `Cell`

### How to determine if a `Cell` is empty

To check if there is any data in the [`Cell{:tact}`](/book/types#primitive-types), we should first convert it to the [`Slice{:tact}`](/book/types#primitive-types). If we are only interested in having bits, we should use `dataEmpty(){:tact}`, if only refs - `refsEmpty(){:tact}`. In case we want to check for the presence of any data, regardless of whether it is a bit or ref, we need to use `empty(){:tact}`.

```tact
// Create an empty cell with no data and no refs
let empty_cell: Cell = emptyCell(); // alias for beginCell().endCell()
// Present `cell` as a `slice` to parse it.
let slice: Slice = empty_cell.asSlice();
// Returns `true`, because `slice` doesn't have any data or refs
slice.empty();

// Create a cell with bits and references
let cell_with_data_and_refs: Cell = beginCell().
    storeUint(42, 8).
    storeRef(emptyCell()).
    endCell();
// Change `cell` type to slice with `begin_parse()`
let slice: Slice = cell_with_data_and_refs.asSlice();
// Returns `false`, because `slice` has both data and refs
slice.empty();
```

<Callout>

  **Useful links:**\
  [`empty(){:tact}` in Language→Reference](/language/ref/cells#sliceempty)\
  [`dataEmpty(){:tact}` in Language→Reference](/language/ref/cells#slicedataempty)\
  [`refsEmpty(){:tact}` in Language→Reference](/language/ref/cells#slicerefsempty)\
  [`emptyCell(){:tact}` in Language→Reference](/language/ref/cells#emptycell)\
  [`beginCell(){:tact}` in Language→Reference](/language/ref/cells#begincell)\
  [`endCell(){:tact}` in Language→Reference](/language/ref/cells#builderendcell)

</Callout>

### How to determine if two Cells are equal

Direct comparison:

```tact
let a: Cell = beginCell()
    .storeUint(123, 16)
    .endCell();

let b: Cell = beginCell()
    .storeUint(123, 16)
    .endCell();

let areCellsEqual: Bool = a == b; // true
let areCellsNotEqual: Bool = a != b; // false
```

Note, that direct comparison via `=={:tact}` or `!={:tact}` operators implicitly uses hashes under the hood.

Explicit comparisons using `.hash(){:tact}` are also available:

```tact
let a: Cell = beginCell()
    .storeUint(123, 16)
    .endCell();

let b: Cell = beginCell()
    .storeUint(123, 16)
    .endCell();

let areCellsEqual: Bool = a.hash() == b.hash(); // true
let areCellsNotEqual: Bool = a.hash() != b.hash(); // false
```

<Callout>

  **Useful links:**\
  [`Cell.hash(){:tact}` in Language→Reference](/language/ref/cells#cellhash)

</Callout>

## Sending messages

### How to make a basic reply

```tact
receive() {
    self.reply("Hello, World!".asComment()); // asComment converts a String to a Cell with a comment
}
```

### How to send a simple message

```tact
send(SendParameters{
    bounce: true, // default
    to: destinationAddress,
    value: ton("0.01"), // attached amount of Tons to send
    body: "Hello from Tact!".asComment() // comment (optional)
});
```

### How to send a message with the entire balance

If we need to send the whole balance of the smart contract, then we should use the `SendRemainingBalance{:tact}` send mode. Alternatively, we can use `mode: 128{:tact}`, which has the same meaning.

```tact
send(SendParameters{
    to: ctx.sender,
    value: 0,
    mode: SendRemainingBalance, // or mode: 128
    body: "Hello from Tact!".asComment() // comment (optional)
});
```

### How to send a message with the remaining value

If we want to make a reply to the same sender, we can use the mode `SendRemainingValue{:tact}` (i.e. `mode: 64{:tact}`), which carries all the remaining value of the inbound message in addition to the value initially indicated in the new message.

```tact
receive() {
    send(SendParameters{
        to: sender(),
        value: 0,
        mode: SendRemainingValue,
        body: "Hello from Tact!".asComment() // comment (optional)
    });
}
```

It's often useful to add the `SendIgnoreErrors{:tact}` flag too, in order to ignore any errors arising while processing this message during the action phaseL

```tact
receive() {
    send(SendParameters{
        to: sender(),
        value: 0,
        mode: SendRemainingValue + SendIgnoreErrors,
        body: "Hello from Tact!".asComment() // comment (optional)
    });
}
```

The latter example is identical to using a [`.reply(){:tact}` function](#how-to-make-a-basic-reply).

<Callout>

  **Useful links:**\
  ["Sending messages" in the Book](/book/send#send-message)\
  ["Message `mode`" in the Book](/book/message-mode)

</Callout>

### How to convert a `String` to an `Int`

```tact
// Dangerously casts string as slice for parsing. Use it only if you know what you are doing.
// Try to parse the string as an slice
let string: Slice = "26052021".asSlice();

// A variable to store the number
let number: Int = 0;

while (!string.empty()) {                   // A loop until slice has bytes
    let char: Int = string.loadUint(8);     // load slice bytes
    number = (number * 10) + (char - 48);   // we use ASCII table to get number
}

dump(number);
```

### How to convert an `Int` to a `String`

```tact
let number: Int = 261119911;

// Converting the [number] to String
let numberString: String = number.toString();

// Converting the [number] to Float String
// passed argument `3` is is a exponentiation parameter of expression 10^(-3) that will be used for computing float number. This parameter required to be `0 <= digits < 77`
let floatString: String = number.toFloatString(3);

// Converting the [number] as coins to human readable Strign
let coinsString: String = number.toCoinsString();

dump(numberString); // "261119911"
dump(floatString); // "261119.911"
dump(coinsString); // "0.261119911"
```

<Callout>

  **Useful links:**\
  [`Int.toString(){:tact}` in Language→Reference](/language/ref/strings#inttostring)\
  [`Int.toFloatString(){:tact}` in Language→Reference](/language/ref/strings#inttofloatstring)\
  [`Int.toCoinsString(){:tact}` in Language→Reference](/language/ref/strings#inttocoinsstring)

</Callout>

### How to get the current time

Use the `now(){:tact}` method to obtain the current standard [Unix time](https://en.wikipedia.org/wiki/Unix_time).

If you need to store the time in state or encode it in a message, use the following [serialization](/book/integers#serialization): `Int as uint32{:tact}`.

```tact
let currentTime: Int = now();

if (currentTime > 1672080143) {
    // do something
}
```

<Callout>

  **Useful links:**\
  [`now(){:tact}` in Language→Reference](/language/ref/common#now)\
  ["Current Time" in Tact-By-Example](https://tact-by-example.org/04-current-time)

</Callout>

### How to generate a random number

```tact
// Declare a variable to store the random number
let number: Int;

// Generate a new random number, which is an unsigned 256-bit integer
number = randomInt();

// Generate a random number between 1 and 12
number = random(1, 12);
```

<Callout>

  **Useful links:**\
  [`randomInt(){:tact}` in Language→Reference](/language/ref/random#randomInt)\
  [`random(){:tact}` in Language→Reference](/language/ref/random#random)

</Callout>

### How to throw errors

The `throw(){:tact}` function in a contract is useful when we don't know how often to perform a specific action.

It allows intentional exception or error handling, which leads to the termination of the current transaction and reverts any state changes made during that transaction.

```tact
let number: Int = 198;

// the error will be triggered anyway
throw(36);

// the error will be triggered only if the number is greater than 50
nativeThrowWhen(35, number > 50);

// the error will be triggered only if the number is NOT EQUAL to 198
nativeThrowUnless(39, number == 198);
```

<Callout>

  **Useful links:**\
  [`throw(){:tact}` in Language→Reference](/language/ref/advanced#throw)\
  [Errors in Tact-By-Example](https://tact-by-example.org/03-errors)

</Callout>

### How to send a message with a long text comment

If we need to send a message with a lengthy text comment, we should create a [`String{:tact}`](/book/types#primitive-types) that consists of more than $127$ characters. To do this, we can utilize the [`StringBuilder{:tact}`](/book/types#primitive-types) primitive type and its methods called `beginComment(){:tact}` and `append(){:tact}`. Prior to sending, we should convert this string into a cell using the `toCell(){:tact}` method.

```tact
let comment: StringBuilder = beginComment();
let longString = "..."; // Some string with more than 127 characters.
str_builder.append(longString);

send(SendParameters{
    to: ctx.sender,
    value: 0,
    mode: SendIgnoreErrors,
    body: longString.toCell(),
    bounce: true,
});
```

<Callout>

  **Useful links:**\
  ["Sending messages" in the Book](/book/send#send-message)\
  [`StringBuilder{:tact}` in the Book](/book/types#primitive-types)\
  [`Cell{:tact}` in Language→Reference](/language/ref/cells)

</Callout>

### How to calculate the NFT item `Address` by its index

For Tact's example, you should have the Tact code of the NFT item contract, placed in the same file. You can use the function as you wish, both inside and outside of a contract.

For FunC's example, you should have the code of item contract as a [`Cell{:tact}`](/book/types#primitive-types). The function can be used outside of a contract by changing `self.nftItemCode{:tact}` with a preassigned `nftItemCode`.

Tact:

```tact

get fun getNftItemInit(item_index: Int): StateInit {
// Arguments for NftItem may vary, depending on contract
    return initOf NftItem(collectionAddress, item_index, self.owner_address, self.collection_content);
}

let itemIndex: Int = 0; // put your index
let itemInit: StateInit = self.getNftItemInit(itemIndex);
let itemAddress: Address = contractAddress(nft_init);
```

FunC (may also vary depending on collection's `deploy_item(){:tact}` function):

```func
fun getNftItemInit(item_index: Int): StateInit {
    let data: Cell = beginCell().storeUint(item_index,64).storeSlice(self.nFTContractAddress.asSlice()).endCell();
    let itemInit: StateInit = StateInit{
        data: data,
        code: self.nftItemCode
    };
    return itemInit;
}

let itemIndex: Int = 0; // put your index
let itemAddress: Address = contractAddress(self.getNftItemInit(itemIndex));
```

<Callout>

  **Useful links:**\
  [`initOf{:tact}` in the Book](/book/expressions#initof)\
  [`contractAddress(){:tact}` in Language→Reference](/language/ref/common#contractaddress)\
  [Tact collection and item contracts example](https://github.com/howardpen9/nft-template-in-tact/blob/tutorial/sources/contract.tact)\
  [FunC collection and item contracts example](https://github.com/Cosmodude/TAP/tree/main/contracts)

</Callout>

## Receiving messages

### How to check sender privileges using Ownable trait

```tact
// Ownable has to be imported from stdlib, as well as Deployable, for convenience:
import "@stdlib/ownable";
import "@stdlib/deploy";

message FooBarMsg {
    newVal: Int as uint32;
}

// Ownable trait can limit certain actions to the owner only
contract SenderChecker with Deployable, Ownable {
    owner: Address;     // Ownable trait requires you to add this exact state variable
    val: Int as uint32; // some value

    init() {
        // we can initialize owner to any value we want, the deployer in this case:
        self.owner = sender();
        self.val = 0;
    }

    receive("inc") {
        require(self.owner == sender(), "Only the owner can increase the value!");
        self.val += 1;
    }

    receive(msg: FooBarMsg) {
        require(self.owner == sender(), "Only the owner can set the value!");
        self.val = msg.newVal;
    }
}
```
